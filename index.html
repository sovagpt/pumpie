<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BONK FM 24.7</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @font-face {
            font-family: 'Bright Aura';
            src: url('https://raw.githubusercontent.com/sovagpt/oiunk/main/Bright%20Aura.otf') format('opentype');
            font-display: swap;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .radio-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            text-align: center;
            width: fit-content;
            margin: 0 auto;
        }

        .logo {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tagline {
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .visual-container {
            position: relative;
            width: 1403px;
            height: 992px;
            margin: 20px auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            background: #000;
        }

        /* Sliding News Ticker Overlay */
        .ticker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: transparent;
            z-index: 15;
            overflow: hidden;
        }

        .ticker-content {
            display: flex;
            align-items: center;
            height: 100%;
            white-space: nowrap;
            animation: scroll-ticker 2000s linear infinite !important;
            font-family: 'Bright Aura', 'Comic Sans MS', cursive, sans-serif;
            font-weight: bold;
            font-size: 20px;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            will-change: transform;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        @keyframes scroll-ticker {
            0% {
                transform: translateX(100%);
            }
            100% {
                transform: translateX(-100%);
            }
        }

        .ticker-item {
            display: inline-block;
            margin-right: 60px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px 15px 15px 5px;
            border: none;
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4), 
                        inset -2px -2px 4px rgba(0, 0, 0, 0.1);
            transform: perspective(100px) rotateX(5deg) rotateY(-5deg);
            min-width: 160px;
            text-align: center;
            color: #333;
            font-family: 'Bright Aura', 'Comic Sans MS', cursive, sans-serif;
        }

        .coin-price {
            color: #333;
            font-weight: bold;
            text-shadow: none;
        }

        .price-up {
            color: #00cc33;
            text-shadow: none;
            font-weight: bold;
        }

        .price-down {
            color: #ff3333;
            text-shadow: none;
            font-weight: bold;
        }

        .ticker-breaking {
            background: rgba(255, 69, 0, 0.8);
            color: #fff;
            border-color: #ff4500;
            animation: flash 1s infinite alternate;
        }

        @keyframes flash {
            0% { 
                opacity: 1; 
                transform: scale(1);
            }
            100% { 
                opacity: 0.8; 
                transform: scale(1.05);
            }
        }

        .studio-img, .porky-gif {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .porky-gif {
            display: none;
        }

        .studio-img.visible {
            display: block;
        }

        .porky-gif.visible {
            display: block;
        }

        /* Perky Reporter Styles */
        .perky-reporter {
            position: absolute;
            left: -400px;
            top: 50%;
            transform: translateY(-50%);
            width: 350px;
            height: 600px;
            z-index: 10;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            opacity: 0;
        }

        .perky-reporter.visible {
            left: 20px;
            opacity: 1;
        }

        .perky-reporter img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .perky-badge {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.3);
            border: 2px solid white;
        }

        /* Now Playing - Simple Text Bottom Right */
        .now-playing {
            position: absolute;
            bottom: 28px;
            left: 66%;
            transform: translateX(-50%);
            z-index: 12;
            display: none;
            pointer-events: none;
        }

        .now-playing.visible {
            display: block;
            animation: textFadeIn 0.5s ease-out;
        }

        @keyframes textFadeIn {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .now-playing-icon {
            display: none;
        }

        .now-playing-info {
            text-align: center;
        }

        .now-playing-label {
            display: none;
        }

        .now-playing-track {
            color: #ffffff;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Bright Aura', 'Comic Sans MS', cursive, sans-serif;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            max-width: 400px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        /* Social Media Feed - Updated size */
        .social-feed {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 350px;
            height: 400px;
            z-index: 20;
            display: block;
            opacity: 0;
            transform: translateX(-100%);
            transition: all 0.5s ease-in-out;
            pointer-events: none;
        }

        .social-feed.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .social-feed-content {
            height: 100%;
            overflow: hidden;
            padding: 0;
            display: flex;
            flex-direction: column-reverse;
        }

        .social-message {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px 15px 15px 5px;
            padding: 14px 18px;
            margin-bottom: 12px;
            font-size: 14px;
            color: #333;
            border: none;
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4), 
                        inset -2px -2px 4px rgba(0, 0, 0, 0.1);
            transform: perspective(100px) rotateX(5deg) rotateY(-5deg);
            word-wrap: break-word;
            max-width: 320px;
            position: relative;
            animation: bubbleSlideIn 0.4s ease-out;
            font-family: 'Bright Aura', 'Comic Sans MS', cursive, sans-serif;
            font-weight: bold;
        }

        .social-message:nth-child(1) { opacity: 1; }
        .social-message:nth-child(2) { opacity: 0.9; }
        .social-message:nth-child(3) { opacity: 0.8; }
        .social-message:nth-child(4) { opacity: 0.7; }
        .social-message:nth-child(5) { opacity: 0.6; }
        .social-message:nth-child(6) { opacity: 0.5; }
        .social-message:nth-child(7) { opacity: 0.4; }
        .social-message:nth-child(8) { opacity: 0.3; }
        .social-message:nth-child(9) { opacity: 0.2; }
        .social-message:nth-child(10) { opacity: 0.1; }
        .social-message:nth-child(n+11) { opacity: 0; }

        .social-message.crypto-bullish {
            background: rgba(255, 255, 255, 0.95);
            border-left: 4px solid #00ff41;
        }

        .social-message.crypto-bearish {
            background: rgba(255, 255, 255, 0.95);
            border-left: 4px solid #ff3333;
        }

        .social-message.meme {
            background: rgba(255, 255, 255, 0.95);
            border-left: 4px solid #ff9500;
        }

        .social-message.breaking {
            background: rgba(255, 255, 255, 0.95);
            border-left: 4px solid #ff1493;
            animation: breakingPulse 2s infinite;
        }

        .social-username {
            font-weight: bold;
            color: #4ecdc4;
            margin-right: 5px;
            font-size: 11px;
        }

        .social-username.vip {
            color: #ff9500;
        }

        .social-username.diamond {
            color: #00ff41;
        }

        .social-message-text {
            margin-top: 3px;
            line-height: 1.3;
            font-size: 12px;
            color: #333;
        }

        .status-display {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff41;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff41;
            border: 2px solid #00ff41;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.stop {
            background: linear-gradient(45deg, #ff4757, #ff3742);
        }

        .btn.breaking {
            background: linear-gradient(45deg, #ff9500, #ff6b00);
            animation: pulse-orange 2s infinite;
        }

        .btn.knowledge {
            background: linear-gradient(45deg, #9c88ff, #6c63ff);
        }

        .btn.perky {
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            animation: pulse-pink 2s infinite;
        }

        @keyframes pulse-orange {
            0% { box-shadow: 0 0 0 0 rgba(255, 149, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 149, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 149, 0, 0); }
        }

        @keyframes pulse-pink {
            0% { box-shadow: 0 0 0 0 rgba(255, 20, 147, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 20, 147, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 20, 147, 0); }
        }

        .audio-player {
            width: 100%;
            margin: 20px 0;
            border-radius: 10px;
        }

        .config-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .config-section h3 {
            color: #fff;
            margin-bottom: 15px;
        }

        .config-section input, .config-section textarea, .config-section select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.9);
        }

        .topic-section {
            background: rgba(108, 99, 255, 0.1);
            border: 2px solid #6c63ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .topic-section h3 {
            color: #6c63ff;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .topic-input {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #6c63ff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-size: 14px;
            min-height: 100px;
            resize: vertical;
        }

        .topic-input:focus {
            outline: none;
            border-color: #9c88ff;
            box-shadow: 0 0 10px rgba(108, 99, 255, 0.3);
        }

        .topic-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .topic-queue {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .topic-item {
            background: rgba(108, 99, 255, 0.2);
            border-left: 4px solid #6c63ff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            color: #fff;
            position: relative;
        }

        .topic-item.urgent {
            border-left-color: #ff6b00;
            background: rgba(255, 149, 0, 0.2);
        }

        .topic-item.perky-report {
            border-left-color: #ff1493;
            background: rgba(255, 20, 147, 0.2);
        }

        .topic-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            opacity: 0.8;
        }

        .topic-content {
            font-size: 14px;
            margin: 5px 0;
        }

        .topic-tags {
            font-size: 11px;
            color: #6c63ff;
            margin-top: 5px;
        }

        .remove-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .remove-btn:hover {
            background: #ff3742;
        }

        .news-ticker {
            background: rgba(0, 0, 0, 0.8);
            color: #00ff41;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 100px;
            overflow-y: auto;
        }

        .stats-display {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            color: #fff;
            min-width: 100px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .knowledge-section {
            background: rgba(156, 136, 255, 0.1);
            border: 2px solid #9c88ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .knowledge-section h3 {
            color: #9c88ff;
            margin-bottom: 15px;
        }

        .knowledge-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .knowledge-item {
            color: #fff;
            padding: 8px;
            margin: 5px 0;
            border-left: 3px solid #9c88ff;
            background: rgba(156, 136, 255, 0.1);
            border-radius: 3px;
            font-size: 13px;
        }

        .reporter-toggle {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }

        .toggle-label {
            color: #fff;
            font-size: 14px;
            margin-right: 10px;
        }

        .reporter-options {
            display: flex;
            gap: 10px;
        }

        .reporter-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #6c63ff;
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .reporter-option.perky {
            border-color: #ff1493;
        }

        .reporter-option.active {
            background: #6c63ff;
        }

        .reporter-option.perky.active {
            background: #ff1493;
        }

        /* Sponsor Video Styles - Fixed border */
        .simple-sponsor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 800px;
            height: 600px;
            z-index: 9999;
            display: none;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .simple-sponsor.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .simple-sponsor video {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            box-shadow: none;
            border: none;
            outline: none;
        }

        .simple-sponsor h3 {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            padding: 8px 20px;
            border-radius: 25px;
            margin: 0;
            font-family: 'Bright Aura', 'Comic Sans MS', cursive, sans-serif;
            font-size: 14px;
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.5);
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="radio-container">
        <div class="logo">OINK FM</div>
        <div class="tagline">24.7 AI Crypto & Memecoin Radio - Hosted by Porky</div>
        
        <div class="visual-container">
            <!-- Sliding News Ticker Overlay -->
            <div class="ticker-overlay">
                <div class="ticker-content" id="tickerContent">
                    <span id="cryptoTicker">Loading crypto prices...</span>
                </div>
            </div>

            <!-- Studio Image -->
            <img id="studioImg" class="studio-img visible" 
                 src="https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/images/studio.jpg" 
                 alt="Studio">
            
            <!-- Porky GIF -->
            <img id="porkyGif" class="porky-gif" 
                 src="https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/images/porky.gif" 
                 alt="Porky">

            <!-- Porky Blink GIF -->
            <img id="porkyBlink" class="porky-gif" 
                 src="https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/images/porkyblink.gif" 
                 alt="Porky Blink">

            <!-- Perky Reporter -->
            <div id="perkyReporter" class="perky-reporter">
                <img src="https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/images/reporter.gif" alt="Perky Reporter">
            </div>

            <!-- Now Playing Display -->
            <div id="nowPlaying" class="now-playing">
                <div class="now-playing-icon">üéµ</div>
                <div class="now-playing-info">
                    <div class="now-playing-label">Now Playing</div>
                    <div id="nowPlayingTrack" class="now-playing-track">Loading...</div>
                </div>
            </div>

            <!-- Social Media Feed -->
            <div id="socialFeed" class="social-feed">
                <div id="socialFeedContent" class="social-feed-content">
                    <div class="social-message">
                        <span class="social-username">OinkFan420</span>
                        <span class="social-timestamp">now</span>
                        <div class="social-message-text">BONK FM is fire! üî• Bonky dropping alpha!</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="status-display" id="statusDisplay">
            üéôÔ∏è Ready to broadcast... Click Start Show!
        </div>

        <div class="stats-display">
            <div class="stat-box">
                <div class="stat-number" id="queueCount">0</div>
                <div class="stat-label">Topics Queued</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="memoryCount">0</div>
                <div class="stat-label">Memory Entries</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="knowledgeCount">0</div>
                <div class="stat-label">Knowledge Items</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="songCount">0</div>
                <div class="stat-label">Songs Available</div>
            </div>
        </div>

        <div class="news-ticker" id="newsTicker">
            Latest crypto intel will appear here...
        </div>

        <div class="controls">
            <button class="btn" onclick="startShow()">üéôÔ∏è Start Show</button>
            <button class="btn stop" onclick="stopShow()">‚èπÔ∏è Stop Show</button>
            <button class="btn" onclick="skipToNext()">‚è≠Ô∏è Skip Segment</button>
            <button class="btn breaking" onclick="breakingNews()">üì° Breaking News</button>
            <button class="btn perky" onclick="perkyReport()">üì∫ Perky Report</button>
            <button class="btn knowledge" onclick="viewKnowledge()">üß† View Knowledge</button>
        </div>

        <audio class="audio-player" id="audioPlayer" controls>
            Your browser does not support the audio element.
        </audio>

        <div class="topic-section">
            <h3>üéØ Topic Queue Management</h3>
            <p style="color: #fff; margin-bottom: 10px;">
                <strong>Curate what Porky discusses!</strong> Add topics and he'll work through them with his growing knowledge.
            </p>
            
            <textarea id="topicInput" class="topic-input" 
                      placeholder="What should Porky discuss next?

Examples:
- New Solana memecoin $BONK surging 300% 
- Ethereum gas fees hit all-time low
- Major whale moved 50,000 BTC to Coinbase
- BlackRock Bitcoin ETF rumors heating up
- Pump.fun launches new feature for creators
- DeFi protocol launches on Base chain
- Celebrity endorses new memecoin
- Regulatory news from SEC about crypto"></textarea>
            
            <div style="display: flex; gap: 10px; margin: 10px 0;">
                <select id="topicType" style="width: 150px;">
                    <option value="general">General</option>
                    <option value="breaking_news">Breaking News</option>
                    <option value="market_analysis">Market Analysis</option>
                    <option value="memecoin">Memecoin Focus</option>
                    <option value="defi">DeFi Update</option>
                    <option value="regulatory">Regulatory News</option>
                    <option value="perky_report">üì∫ Perky Report</option>
                </select>
                
                <select id="topicPriority" style="width: 120px;">
                    <option value="normal">Normal</option>
                    <option value="urgent">Urgent</option>
                    <option value="low">Low Priority</option>
                </select>
                
                <input type="text" id="topicTags" placeholder="Tags (comma separated)" style="flex: 1;">
            </div>

            <div class="reporter-toggle">
                <span class="toggle-label">Reporter:</span>
                <div class="reporter-options">
                    <div class="reporter-option active" data-reporter="porky">üê∑ Porky</div>
                    <div class="reporter-option perky" data-reporter="perky">üì∫ Perky</div>
                </div>
            </div>

            <div class="topic-controls">
                <button class="btn" onclick="addTopic()">üìù Add to Queue</button>
                <button class="btn breaking" onclick="addUrgentTopic()">üö® Add Urgent</button>
                <button class="btn perky" onclick="addPerkyReport()">üì∫ Add Perky Report</button>
                <button class="btn stop" onclick="clearQueue()">üóëÔ∏è Clear Queue</button>
                <button class="btn" onclick="refreshQueue()">üîÑ Refresh</button>
            </div>

            <div class="topic-queue" id="topicQueue">
                <div style="color: #999; text-align: center; padding: 20px;">
                    No topics queued... Add some content for Porky!
                </div>
            </div>
        </div>

        <div class="knowledge-section">
            <h3>üß† Porky's Knowledge Base</h3>
            <p style="color: #fff; margin-bottom: 10px;">
                Porky's accumulated knowledge grows with every show. He references past topics to build ongoing narratives.
            </p>
            
            <div style="display: flex; gap: 10px; margin: 10px 0;">
                <button class="btn knowledge" onclick="viewMemory()">üìö Recent Memory</button>
                <button class="btn knowledge" onclick="viewKnowledge()">üéì Knowledge Base</button>
                <button class="btn stop" onclick="clearMemory()">üßπ Clear All Data</button>
            </div>

            <div class="knowledge-list" id="knowledgeDisplay">
                <div style="color: #999; text-align: center; padding: 20px;">
                    Porky's knowledge base is empty... Start the show to build it!
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>üéµ Music Library Status</h3>
            <textarea id="songList" rows="3" placeholder="Music files will appear here automatically...">
Loading music library from GitHub...
            </textarea>
        </div>
    </div>

    <!-- Sponsor Video Modal -->
    <div id="simpleSponsor" class="simple-sponsor">
        <video id="simpleVideo"></video>
    </div>
    <script>
    class OinkFMRadio {
        constructor() {
            this.isPlaying = false;
            this.currentSegment = null;
            this.songs = [];
            this.trackList = {};
            this.selectedReporter = 'porky';
            this.justCompletedReport = false;
            this.lastTickerContent = '';
            this.blinkInterval = null;
            this.isBlinking = false;
            this.preloadedAudio = {
                porky: null,
                perky: null
            };
            this.audioGenerationQueue = [];
            
            // DOM elements
            this.studioImg = document.getElementById('studioImg');
            this.porkyGif = document.getElementById('porkyGif');
            this.porkyBlink = document.getElementById('porkyBlink');
            this.perkyReporter = document.getElementById('perkyReporter');
            this.audioPlayer = document.getElementById('audioPlayer');
            this.statusDisplay = document.getElementById('statusDisplay');
            this.newsTicker = document.getElementById('newsTicker');
            this.topicInput = document.getElementById('topicInput');
            this.topicQueue = document.getElementById('topicQueue');
            this.knowledgeDisplay = document.getElementById('knowledgeDisplay');
            this.tickerContent = document.getElementById('tickerContent');
            this.cryptoTicker = document.getElementById('cryptoTicker');
            this.nowPlaying = document.getElementById('nowPlaying');
            this.nowPlayingTrack = document.getElementById('nowPlayingTrack');
            this.socialFeed = document.getElementById('socialFeed');
            this.socialFeedContent = document.getElementById('socialFeedContent');
            this.socialMessages = [];
            this.lastTopicKeywords = [];
            
            this.setupEventListeners();
            this.updateStatus('üê∑ OINK FM loaded and ready!');
            this.loadTrackList();
            this.loadMusicLibrary();
            this.refreshData();
            
            // Start ticker immediately and then get real data
            this.forceStartTicker();
            this.fetchCryptoNews().then(data => {
                if (data) {
                    this.updateNewsTicker(data);
                    this.updateOverlayTicker(data);
                    console.log('üéØ Real crypto ticker loaded');
                }
            }).catch(error => {
                console.error('Failed to load real crypto data, keeping demo data');
            });
        }

        async loadTrackList() {
            try {
                console.log('üéµ Loading tracklist from GitHub...');
                const response = await fetch('https://raw.githubusercontent.com/sovagpt/oiunk/main/tracklist.txt');
                
                if (response.ok) {
                    const trackData = await response.text();
                    
                    // Parse the tracklist.txt file
                    const lines = trackData.split('\n');
                    this.trackList = {};
                    
                    lines.forEach(line => {
                        const trimmedLine = line.trim();
                        if (trimmedLine && trimmedLine.includes('=')) {
                            const [trackFile, trackInfo] = trimmedLine.split('=');
                            this.trackList[trackFile.trim()] = trackInfo.trim();
                        }
                    });
                    
                    console.log(`‚úÖ Loaded ${Object.keys(this.trackList).length} track names`);
                    this.updateStatus(`üéµ Track list loaded: ${Object.keys(this.trackList).length} tracks named`);
                } else {
                    console.log('‚ùå No tracklist.txt found - using generic names');
                    this.trackList = {};
                }
            } catch (error) {
                console.error('Error loading tracklist:', error);
                this.trackList = {};
            }
        }

        getTrackName(songUrl) {
            // Extract filename from URL (e.g., track001.mp3)
            const filename = songUrl.split('/').pop();
            const trackKey = filename.replace('.mp3', '');
            
            // Return track info from tracklist, or generic name
            return this.trackList[trackKey] || `Unknown Track (${trackKey})`;
        }

        showNowPlaying(trackName) {
            if (this.nowPlayingTrack && this.nowPlaying) {
                this.nowPlayingTrack.textContent = trackName;
                this.nowPlaying.classList.add('visible');
                console.log(`üéµ Now Playing: ${trackName}`);
            }
        }

        hideNowPlaying() {
            if (this.nowPlaying) {
                this.nowPlaying.classList.remove('visible');
                console.log('üéµ Hiding Now Playing display');
            }
        }

        startPorkyBlinking() {
            if (this.blinkInterval) return;
            
            console.log('üê∑ Starting Porky blink routine...');
            
            const scheduleNextBlink = () => {
                const nextBlinkTime = Math.random() * 3000 + 2000;
                
                this.blinkInterval = setTimeout(() => {
                    this.doPorkyBlink();
                    scheduleNextBlink();
                }, nextBlinkTime);
            };
            
            scheduleNextBlink();
        }
        
        doPorkyBlink() {
            if (this.isBlinking) return;
            if (!this.studioImg.classList.contains('visible')) return;
            
            this.isBlinking = true;
            
            this.studioImg.classList.remove('visible');
            this.porkyBlink.classList.add('visible');
            
            setTimeout(() => {
                this.porkyBlink.classList.remove('visible');
                this.studioImg.classList.add('visible');
                this.isBlinking = false;
            }, 200);
        }
        
        stopPorkyBlinking() {
            if (this.blinkInterval) {
                clearTimeout(this.blinkInterval);
                this.blinkInterval = null;
                console.log('üê∑ Stopped Porky blinking');
            }
            
            if (this.isBlinking) {
                this.porkyBlink.classList.remove('visible');
                this.studioImg.classList.add('visible');
                this.isBlinking = false;
            }
        }

        setupEventListeners() {
            if (this.porkyGif) {
                this.porkyGif.addEventListener('load', () => {
                    console.log('‚úÖ Porky GIF loaded and ready');
                });
            } else {
                console.error('‚ùå Porky GIF element not found');
            }
            
            if (this.studioImg) {
                this.studioImg.addEventListener('load', () => {
                    console.log('‚úÖ Studio image loaded');
                });
            } else {
                console.error('‚ùå Studio image element not found');
            }

            document.querySelectorAll('.reporter-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    document.querySelectorAll('.reporter-option').forEach(opt => opt.classList.remove('active'));
                    e.target.classList.add('active');
                    this.selectedReporter = e.target.dataset.reporter;
                    console.log(`Selected reporter: ${this.selectedReporter}`);
                });
            });

            setInterval(() => {
                if (!this.isPlaying) {
                    this.refreshData();
                }
            }, 30000);
        }

        async loadMusicLibrary() {
            console.log('üéµ Loading music library from GitHub...');
            this.updateStatus('üéµ Scanning GitHub for music files...');
            
            const musicUrls = [];
            
            for (let i = 1; i <= 25; i++) {
                const trackNumber = i.toString().padStart(3, '0');
                musicUrls.push(`https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/music/track${trackNumber}.mp3`);
            }
            
            const validSongs = [];
            let foundCount = 0;
            
            for (const url of musicUrls) {
                try {
                    const response = await fetch(url, { method: 'HEAD' });
                    if (response.ok) {
                        validSongs.push(url);
                        foundCount++;
                        console.log(`‚úÖ Found song ${foundCount}: ${url.split('/').pop()}`);
                        
                        if (foundCount % 3 === 0) {
                            this.updateStatus(`üéµ Found ${foundCount} songs so far...`);
                        }
                    }
                } catch (error) {
                    // Song doesn't exist, continue searching
                }
            }
            
            this.songs = validSongs;
            
            if (validSongs.length > 0) {
                this.updateStatus(`üéµ Music library loaded: ${validSongs.length} songs ready!`);
                console.log(`üéµ Total music library: ${validSongs.length} songs`);
                this.displayMusicLibrary();
            } else {
                this.updateStatus('‚ùå No music found - upload MP3s to assets/music/');
                console.log('‚ùå No songs found in GitHub music folder');
                this.songs = [
                    'https://www.soundjay.com/misc/sounds/beep-07a.wav',
                    'https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3'
                ];
                this.updateStatus('üéµ Using fallback music - upload your tracks to assets/music/');
            }
            
            document.getElementById('songCount').textContent = this.songs.length;
        }

        displayMusicLibrary() {
            const songListTextarea = document.getElementById('songList');
            if (songListTextarea && this.songs.length > 0) {
                const songNames = this.songs.map(url => url.split('/').pop());
                songListTextarea.value = songNames.join('\n');
                songListTextarea.placeholder = `${this.songs.length} songs loaded automatically from GitHub`;
                songListTextarea.rows = Math.min(10, Math.max(3, songNames.length));
            }
        }

        // Force start ticker with demo data
        forceStartTicker() {
            console.log('üöÄ Force starting crypto ticker...');
            
            const demoData = [
                {name: "Bitcoin", symbol: "btc", current_price: 43500, price_change_percentage_24h: 2.1},
                {name: "Ethereum", symbol: "eth", current_price: 2650, price_change_percentage_24h: -0.8},
                {name: "Solana", symbol: "sol", current_price: 98, price_change_percentage_24h: 4.2},
                {name: "BNB", symbol: "bnb", current_price: 310, price_change_percentage_24h: 1.5},
                {name: "XRP", symbol: "xrp", current_price: 0.52, price_change_percentage_24h: -2.1},
                {name: "Cardano", symbol: "ada", current_price: 0.38, price_change_percentage_24h: 0.9}
            ];
            
            this.updateOverlayTicker(demoData);
        }

        async fetchCryptoNews() {
            try {
                console.log('üîÑ Fetching crypto data...');
                this.updateStatus("üì° Fetching latest crypto data...");
                
                // Add timeout and better error handling
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=bitcoin,ethereum,solana,binancecoin,ripple,cardano,dogecoin,matic-network,chainlink,avalanche-2&order=market_cap_desc&per_page=10&page=1&sparkline=false&price_change_percentage_24h', {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Crypto data fetched successfully:', data);
                
                return data;
                
            } catch (error) {
                console.error('‚ùå Error fetching crypto data:', error);
                
                // Return fallback demo data
                const fallbackData = [
                    {name: "Bitcoin", symbol: "btc", current_price: 43500, price_change_percentage_24h: 2.1},
                    {name: "Ethereum", symbol: "eth", current_price: 2650, price_change_percentage_24h: -0.8},
                    {name: "Solana", symbol: "sol", current_price: 98, price_change_percentage_24h: 4.2},
                    {name: "BNB", symbol: "bnb", current_price: 310, price_change_percentage_24h: 1.5},
                    {name: "XRP", symbol: "xrp", current_price: 0.52, price_change_percentage_24h: -2.1},
                    {name: "Cardano", symbol: "ada", current_price: 0.38, price_change_percentage_24h: 0.9}
                ];
                
                console.log('üìä Using fallback crypto data');
                return fallbackData;
            }
        }

        updateNewsTicker(data) {
    if (Array.isArray(data)) {
        const tickerText = data.map(coin => 
            `${coin.name}: ${coin.current_price.toFixed(2)} (${coin.price_change_percentage_24h > 0 ? '+' : ''}${coin.price_change_percentage_24h.toFixed(1)}%)`
        ).join(' ‚Ä¢ ');
        this.newsTicker.textContent = tickerText;
        
        // REMOVED the circular call to updateOverlayTicker here
    } else {
        this.newsTicker.textContent = data;
        this.addBreakingToTicker(data);
    }
}

        updateOverlayTicker(cryptoData) {
    console.log('üéØ Updating overlay ticker with data:', cryptoData);
    
    if (!cryptoData || cryptoData.length === 0) {
        console.error('‚ùå No crypto data provided to ticker');
        // Set a default message
        if (this.cryptoTicker) {
            this.cryptoTicker.innerHTML = '<span class="ticker-item">Loading crypto prices...</span>';
        }
        return;
    }
    
    const tickerItems = cryptoData.map(coin => {
        const isUp = coin.price_change_percentage_24h > 0;
        const arrow = isUp ? 'üìà' : 'üìâ';
        const priceColorClass = isUp ? 'price-up' : 'price-down';
        
        return `<span class="ticker-item">
            <span class="coin-price">${coin.symbol.toUpperCase()}</span> 
            <span class="${priceColorClass}">$${coin.current_price < 1 ? coin.current_price.toFixed(4) : coin.current_price.toLocaleString()}</span> 
            <span class="${priceColorClass}">${arrow}${Math.abs(coin.price_change_percentage_24h).toFixed(1)}%</span>
        </span>`;
    }).join('');
    
    // Repeat the content multiple times for seamless scrolling
    const fullContent = (tickerItems + ' ').repeat(10);
    
    console.log('üéØ Setting ticker content...');
    
    if (this.cryptoTicker) {
        // Stop any existing animation
        this.cryptoTicker.style.animation = 'none';
        
        // Set the content
        this.cryptoTicker.innerHTML = fullContent;
        
        // Force reflow and restart animation
        this.cryptoTicker.offsetHeight;
        this.cryptoTicker.style.animation = 'scroll-ticker 2000s linear infinite';
        
        console.log('‚úÖ Crypto ticker updated and animated');
    } else {
        console.error('‚ùå Crypto ticker element not found!');
    }
    
    // Update the news ticker separately (without calling updateOverlayTicker again)
    if (Array.isArray(cryptoData)) {
        const tickerText = cryptoData.map(coin => 
            `${coin.name}: ${coin.current_price.toFixed(2)} (${coin.price_change_percentage_24h > 0 ? '+' : ''}${coin.price_change_percentage_24h.toFixed(1)}%)`
        ).join(' ‚Ä¢ ');
        if (this.newsTicker) {
            this.newsTicker.textContent = tickerText;
        }
    }
}

        addBreakingToTicker(breakingNews) {
           this.newsTicker.textContent = `üö® BREAKING: ${breakingNews} üö®`;
           
           setTimeout(() => {
               // Don't reset if there's newer data
           }, 30000);
       }
       // Social Media Feed Functions
        async generateSocialMessages(currentTopic = null, cryptoData = null) {
            try {
                const response = await fetch('/api/enhanced-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        requestType: 'social_feed',
                        currentTopic: currentTopic,
                        cryptoData: cryptoData,
                        recentKeywords: this.lastTopicKeywords
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    return data.messages || this.getFallbackMessages(currentTopic);
                } else {
                    return this.getFallbackMessages(currentTopic);
                }
            } catch (error) {
                console.error('Social feed generation failed:', error);
                return this.getFallbackMessages(currentTopic);
            }
        }

        getFallbackMessages(currentTopic = null) {
    const genericMessages = [
        // CHANGE THESE MESSAGES
        { username: "CryptoWhale", text: "BONK FM keeping me updated on the charts üìà", type: "crypto-bullish" },
        { username: "BuddyFan69", text: "Buddy's voice is so soothing while my portfolio bleeds üò≠", type: "crypto-bearish" },
        { username: "DiamondHands", text: "Thanks for the alpha Buddy! üíéüôå", type: "diamond" },
        { username: "MoonBoy420", text: "When lambo Buddy? üöóüåô", type: "meme" },
        { username: "DeFiDegen", text: "This radio station hits different fr", type: "vip" },
        { username: "SolanaSister", text: "SOL gang rise up! üöÄ", type: "crypto-bullish" },
        { username: "EthMaxi", text: "ETH still king don't @ me", type: "crypto-bullish" },
        { username: "RugPuller", text: "Buddy never rugs us with bad takes üêï", type: "meme" },
        { username: "YieldFarmer", text: "Farming yields and listening to BONK FM üåæ", type: "crypto-bullish" },
        { username: "PumpItUp", text: "This track goes hard! üéµ", type: "meme" },
        { username: "DogeCoinMaxis", text: "DOG COINS TO THE MOON! üêïüöÄ", type: "crypto-bullish" },
        { username: "BonkArmy", text: "BONK IS THE WAY! üí™", type: "meme" },
        { username: "WoofWoof", text: "Buddy's barks are pure alpha üêï‚Äçü¶∫", type: "diamond" },
        { username: "TailWagger", text: "This good boy knows crypto! ü¶¥", type: "meme" },
        { username: "PuppyPumper", text: "WOOF WOOF! Let's pump it! üìà", type: "crypto-bullish" }
    ];

            if (currentTopic) {
                if (currentTopic.toLowerCase().includes('bitcoin') || currentTopic.toLowerCase().includes('btc')) {
                    genericMessages.push(
                        { username: "BTCMaxi", text: "Bitcoin mentioned! üß°‚ö°", type: "crypto-bullish" },
                        { username: "SatsStacker", text: "Stack sats and listen to Porky üí∞", type: "crypto-bullish" }
                    );
                }
                if (currentTopic.toLowerCase().includes('pump') || currentTopic.toLowerCase().includes('moon')) {
                    genericMessages.push(
                        { username: "ToTheMoon", text: "PUMP IT PORKY! üöÄüåô", type: "crypto-bullish" },
                        { username: "PumpChaser", text: "I'm ready for this pump! üìà", type: "crypto-bullish" }
                    );
                }
            }

            return genericMessages.slice(0, 5);
        }

        showSocialFeed() {
            console.log('üì± Attempting to show social feed...');
            if (this.socialFeed) {
                this.socialFeed.style.display = 'block';
                // Force a reflow
                this.socialFeed.offsetHeight;
                this.socialFeed.classList.add('visible');
                console.log('üì± Social feed should now be visible');
            } else {
                console.error('‚ùå Social feed element not found!');
            }
        }

        hideSocialFeed() {
            console.log('üì± Hiding social feed...');
            if (this.socialFeed) {
                this.socialFeed.classList.remove('visible');
                // Hide completely after animation
                setTimeout(() => {
                    this.socialFeed.style.display = 'none';
                }, 500);
                console.log('üì± Social feed hidden');
            }
        }

        async addSocialMessage(username, text, type = '', isVip = false) {
            if (!this.socialFeedContent) return;

            const userClass = isVip ? 'vip' : (type === 'diamond' ? 'diamond' : '');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `social-message ${type}`;
            messageDiv.innerHTML = `
                <span class="social-username ${userClass}">${username}</span>
                <div class="social-message-text">${text}</div>
            `;

            // Add to the beginning (newest on top)
            this.socialFeedContent.insertBefore(messageDiv, this.socialFeedContent.firstChild);

            // Keep more messages but let them fade out naturally
            const messages = this.socialFeedContent.querySelectorAll('.social-message');
            if (messages.length > 15) {
                messages[messages.length - 1].remove();
            }
        }

        async startSocialFeedForTopic(topicContent, cryptoData) {
            console.log('üî• STARTING SOCIAL FEED FOR TOPIC:', topicContent?.substring(0, 50));
            
            try {
                const messages = await this.generateSocialMessages(topicContent, cryptoData);
                console.log('üî• GENERATED MESSAGES:', messages);
                
                for (let i = 0; i < messages.length; i++) {
                    setTimeout(() => {
                        if (this.isPlaying) {
                            const msg = messages[i];
                            console.log('üî• ADDING MESSAGE:', msg.text);
                            this.addSocialMessage(
                                msg.username, 
                                msg.text, 
                                msg.type || '', 
                                msg.username.includes('Whale') || msg.username.includes('VIP')
                            );
                        }
                    }, i * (Math.random() * 5000 + 10000)); // Random delays between 10-15 seconds
                }
            } catch (error) {
                console.error('Social feed error:', error);
            }
        }

        // Topic Management Functions
        async addTopic() {
            const content = this.topicInput.value.trim();
            if (!content) {
                this.updateStatus('‚ùå Please enter a topic first!');
                return;
            }

            const topic = {
                content: content,
                type: document.getElementById('topicType').value,
                priority: document.getElementById('topicPriority').value,
                tags: document.getElementById('topicTags').value.split(',').map(t => t.trim()).filter(t => t),
                reporter: this.selectedReporter
            };

            try {
                const response = await fetch('/api/enhanced-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'add_topic',
                        topic: topic
                    })
                });

                if (response.ok) {
                    this.topicInput.value = '';
                    document.getElementById('topicTags').value = '';
                    this.updateStatus('‚úÖ Topic added to queue!');
                    await this.refreshQueue();
                } else {
                    throw new Error('Failed to add topic');
                }
            } catch (error) {
                console.error('Add topic failed:', error);
                this.updateStatus('‚ùå Failed to add topic');
            }
        }

        async addUrgentTopic() {
            document.getElementById('topicPriority').value = 'urgent';
            document.getElementById('topicType').value = 'breaking_news';
            await this.addTopic();
        }

        async addPerkyReport() {
            // Get the content and create topic object directly
            const content = this.topicInput.value.trim();
            if (!content) {
                this.updateStatus('‚ùå Please enter report content for Perky first!');
                return;
            }

            const topic = {
                content: content,
                type: 'perky_report',
                priority: 'normal',
                tags: document.getElementById('topicTags').value.split(',').map(t => t.trim()).filter(t => t),
                reporter: 'perky'  // Explicitly set to perky
            };

            try {
                const response = await fetch('/api/enhanced-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'add_topic',
                        topic: topic
                    })
                });

                if (response.ok) {
                    this.topicInput.value = '';
                    document.getElementById('topicTags').value = '';
                    this.updateStatus('‚úÖ Perky report added to queue!');
                    
                    // Update the UI to show perky is selected
                    document.querySelectorAll('.reporter-option').forEach(opt => opt.classList.remove('active'));
                    document.querySelector('[data-reporter="perky"]').classList.add('active');
                    this.selectedReporter = 'perky';
                    
                    await this.refreshQueue();
                } else {
                    throw new Error('Failed to add perky report');
                }
            } catch (error) {
                console.error('Add perky report failed:', error);
                this.updateStatus('‚ùå Failed to add perky report');
            }
        }

        async removeTopic(topicId) {
            try {
                const response = await fetch(`/api/enhanced-chat?type=topic&id=${topicId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    this.updateStatus('‚úÖ Topic removed');
                    await this.refreshQueue();
                }
            } catch (error) {
                console.error('Remove topic failed:', error);
                this.updateStatus('‚ùå Failed to remove topic');
            }
        }

        async clearQueue() {
            if (confirm('Clear all queued topics?')) {
                try {
                    const response = await fetch('/api/enhanced-chat?type=queue', {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        this.updateStatus('‚úÖ Queue cleared');
                        await this.refreshQueue();
                    }
                } catch (error) {
                    console.error('Clear queue failed:', error);
                }
            }
        }

        async clearMemory() {
            if (confirm('Clear all memory and knowledge data? This cannot be undone!')) {
                try {
                    const response = await fetch('/api/enhanced-chat?type=memory', {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        this.updateStatus('‚úÖ All data cleared');
                        await this.refreshData();
                    }
                } catch (error) {
                    console.error('Clear memory failed:', error);
                }
            }
        }

        async refreshData() {
            await Promise.all([
                this.refreshQueue(),
                this.refreshStats()
            ]);
        }

        async refreshQueue() {
            try {
                const response = await fetch('/api/enhanced-chat?type=queue');
                const data = await response.json();
                this.displayQueue(data.queue || []);
            } catch (error) {
                console.error('Refresh queue failed:', error);
            }
        }

        async refreshStats() {
            try {
                const response = await fetch('/api/enhanced-chat');
                const data = await response.json();
                
                document.getElementById('queueCount').textContent = data.queue?.length || 0;
                document.getElementById('memoryCount').textContent = data.memory?.recent?.length || 0;
                document.getElementById('knowledgeCount').textContent = data.knowledge?.length || 0;
                document.getElementById('songCount').textContent = this.songs.length;
            } catch (error) {
                console.error('Refresh stats failed:', error);
            }
        }

        displayQueue(queue) {
            if (queue.length === 0) {
                this.topicQueue.innerHTML = `
                    <div style="color: #999; text-align: center; padding: 20px;">
                        No topics queued... Add some content for Porky!
                    </div>
                `;
            } else {
                this.topicQueue.innerHTML = queue.map(topic => `
                    <div class="topic-item ${topic.priority === 'urgent' ? 'urgent' : ''} ${topic.type === 'perky_report' || topic.reporter === 'perky' ? 'perky-report' : ''}">
                        <div class="topic-meta">
                            <span>${topic.type} ‚Ä¢ ${topic.priority} ‚Ä¢ ${topic.reporter === 'perky' ? 'üì∫ Perky' : 'üê∑ Porky'}</span>
                            <span>${new Date(topic.timestamp).toLocaleTimeString()}</span>
                            <button class="remove-btn" onclick="radio.removeTopic(${topic.id})">Remove</button>
                        </div>
                        <div class="topic-content">${topic.content}</div>
                        ${topic.tags && topic.tags.length > 0 ? `<div class="topic-tags">Tags: ${topic.tags.join(', ')}</div>` : ''}
                    </div>
                `).join('');
            }
        }

        async viewMemory() {
            try {
                const response = await fetch('/api/enhanced-chat?type=memory');
                const data = await response.json();
                this.displayKnowledge(data.memory?.recent || [], 'Recent Memory');
            } catch (error) {
                console.error('View memory failed:', error);
            }
        }

        async viewKnowledge() {
            try {
                const response = await fetch('/api/enhanced-chat?type=knowledge');
                const data = await response.json();
                this.displayKnowledge(data.knowledge || [], 'Knowledge Base');
            } catch (error) {
                console.error('View knowledge failed:', error);
            }
        }

        displayKnowledge(items, title) {
            if (items.length === 0) {
                this.knowledgeDisplay.innerHTML = `
                    <div style="color: #999; text-align: center; padding: 20px;">
                        No ${title.toLowerCase()} entries... Start the show to build knowledge!
                    </div>
                `;
            } else {
                this.knowledgeDisplay.innerHTML = `
                    <div style="color: #9c88ff; font-weight: bold; margin-bottom: 10px;">${title} (${items.length} entries)</div>
                    ${items.map(item => `
                        <div class="knowledge-item">
                            <div style="font-size: 11px; opacity: 0.7; margin-bottom: 3px;">
                                ${new Date(item.timestamp).toLocaleString()}
                            </div>
                            <div>${item.topic || item.content?.substring(0, 100) + '...' || 'Unknown'}</div>
                            ${item.keywords ? `<div style="font-size: 11px; color: #6c63ff; margin-top: 3px;">Keywords: ${item.keywords.join(', ')}</div>` : ''}
                        </div>
                    `).join('')}
                `;
            }
        }

        // Content Generation Functions
        async generateRadioContent(cryptoData, topicData = null) {
            try {
                const response = await fetch('/api/enhanced-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        cryptoData,
                        requestType: 'segment',
                        topicData: topicData
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                
                await this.refreshStats();
                
                return data.content;
                
            } catch (error) {
                console.error('Enhanced content generation failed:', error);
                this.updateStatus("‚ö†Ô∏è Enhanced API Error - using fallback");
                return "OINK OINK! Porky here on OINK FM! My topic queue is loaded with hot intel and my knowledge base is growing every day! The crypto markets are hog wild and we're building something special here! Let me spin some tracks while I process all this beautiful data!";
            }
        }

        async generatePerkyReport(content) {
            try {
                const response = await fetch('/api/enhanced-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        cryptoData: await this.fetchCryptoNews(),
                        requestType: 'perky_report',
                        fieldIntel: content
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                await this.refreshStats();
                return data.content;
                
            } catch (error) {
                console.error('Perky report generation failed:', error);
                return `Good evening, I'm Perky with a special report. ${content} We'll have more updates on this developing story as it unfolds. Back to you, Porky.`;
            }
        }

        async generatePorkyFollowUp(originalContent, perkyReport) {
            try {
                const response = await fetch('/api/enhanced-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        cryptoData: await this.fetchCryptoNews(),
                        requestType: 'porky_followup',
                        originalContent: originalContent,
                        perkyReport: perkyReport
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                return data.content;
                
            } catch (error) {
                console.error('Porky follow-up generation failed:', error);
                return `OINK OINK! Thanks for that excellent report, Perky! That's exactly the kind of intel our listeners need to hear! My knowledge base is updating with this information and we'll keep tracking this story. Now let me spin some tracks while I process all this data!`;
            }
        }

        async generateBreakingNewsContent(intel) {
            try {
                const response = await fetch('/api/enhanced-chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        cryptoData: await this.fetchCryptoNews(),
                        requestType: 'breaking_news',
                        fieldIntel: intel
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                await this.refreshStats();
                return data.content;
                
            } catch (error) {
                console.error('Breaking news generation failed:', error);
                return `OINK OINK! This is Porky with URGENT intel! ${intel} This is absolutely mental! My knowledge base is telling me this could be huge! More details coming as this develops!`;
            }
        }
        // Audio and TTS Functions
        async generateTTSAudio(text, voiceType = 'porky') {
    try {
        console.log(`üé§ Attempting ElevenLabs TTS for ${voiceType}...`);
        
        const voiceParam = voiceType; // Keep it simple - just pass 'porky' or 'perky'
        
        console.log(`üîó Making request to /api/tts with voice: ${voiceParam}`);
        
        const response = await fetch('/api/tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
                text: text,
                voice: voiceParam
            })
        });

        console.log(`üì° TTS API Response status: ${response.status}`);

        if (response.ok) {
            console.log('‚úÖ ElevenLabs TTS succeeded - creating audio blob...');
            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            console.log('üéµ Audio blob created successfully');
            return audioUrl;
        } else {
            const errorText = await response.text();
            console.error(`‚ùå ElevenLabs TTS failed with status ${response.status}:`, errorText);
            throw new Error(`TTS API Error: ${response.status} - ${errorText}`);
        }
    } catch (error) {
        console.error('‚ùå TTS audio generation failed:', error);
        console.log('üîÑ Falling back to browser TTS...');
        return null;
    }
}

        async playAudio(audioUrl) {
            if (audioUrl) {
                return new Promise((resolve) => {
                    const audio = new Audio(audioUrl);
                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                        resolve();
                    };
                    audio.onerror = () => {
                        console.error('Audio playback failed');
                        URL.revokeObjectURL(audioUrl);
                        resolve();
                    };
                    audio.play().catch(() => {
                        console.error('Audio play failed');
                        resolve();
                    });
                });
            } else {
                console.log('No audio URL provided, using browser TTS fallback');
                return Promise.resolve();
            }
        }

        async playTTSAudio(text, voiceType = 'porky') {
    // DON'T show talking animation yet - wait for audio to be ready
    
    // Try ElevenLabs first
    const audioUrl = await this.generateTTSAudio(text, voiceType);
    
    if (audioUrl) {
        console.log(`üéµ Playing ElevenLabs audio for ${voiceType}`);
        
        // NOW show the talking animation right before playing audio
        if (voiceType === 'pumpie' || voiceType === 'porky') {
            this.showPorkyTalking();
        }
        
        await this.playAudio(audioUrl);
        
        // Go back to studio when audio ends
        if (voiceType === 'pumpie' || voiceType === 'porky') {
            this.showStudio();
        }
    } else {
        console.log(`üé§ Using browser TTS fallback for ${voiceType}`);
        
        // For browser TTS, show animation right before speaking
        if (voiceType === 'pumpie' || voiceType === 'porky') {
            this.showPorkyTalking();
        }
        
        await this.textToSpeech(text, voiceType);
        
        // Go back to studio when speech ends
        if (voiceType === 'pumpie' || voiceType === 'porky') {
            this.showStudio();
        }
    }
}
        async textToSpeech(text, voiceType = 'porky') {
            return new Promise((resolve) => {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = voiceType === 'perky' ? 1.0 : 0.9;
                    utterance.pitch = voiceType === 'perky' ? 1.3 : 1.1;
                    utterance.volume = 0.8;
                    
                    const voices = speechSynthesis.getVoices();
                    let preferredVoice;
                    
                    if (voiceType === 'perky') {
                        preferredVoice = voices.find(voice => 
                            voice.name.toLowerCase().includes('female') || 
                            voice.name.toLowerCase().includes('woman') ||
                            voice.name.includes('Zira') ||
                            voice.name.includes('Hazel')
                        );
                    }
                    
                    if (!preferredVoice) {
                        preferredVoice = voices.find(voice => 
                            voice.name.includes('Google') || 
                            voice.name.includes('Microsoft') ||
                            voice.lang.includes('en-US')
                        );
                    }
                    
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                    }
                    
                    utterance.onend = resolve;
                    utterance.onerror = resolve;
                    
                    speechSynthesis.speak(utterance);
                } else {
                    setTimeout(resolve, text.length * 50);
                }
            });
        }

        // Music and Audio Playback
        async playRandomSong() {
    if (this.songs.length === 0) {
        console.log('üéµ No songs available, skipping music segment');
        await this.delay(30000);
        return { duration: 30000 };
    }
    
    for (let attempt = 0; attempt < 3; attempt++) {
        const randomSong = this.songs[Math.floor(Math.random() * this.songs.length)];
        const trackName = this.getTrackName(randomSong);
        
        try {
            console.log(`üéµ Attempting to play: ${randomSong.split('/').pop()} (attempt ${attempt + 1})`);
            
            return new Promise((resolve) => {
                const songStartTime = Date.now();
                
                this.audioPlayer.onerror = (error) => {
                    const songDuration = Date.now() - songStartTime;
                    console.error(`‚ùå Song failed to play:`, error);
                    this.hideNowPlaying();
                    resolve({ duration: songDuration });
                };
                
                this.audioPlayer.oncanplaythrough = () => {
                    console.log(`‚úÖ Song loaded successfully: ${randomSong.split('/').pop()}`);
                    this.showNowPlaying(trackName);
                    
                    // Schedule DJ drops during the song
                    this.scheduleDJDrops();
                };
                
                this.audioPlayer.onended = () => {
                    const songDuration = Date.now() - songStartTime;
                    console.log(`üéµ Song finished playing (${Math.round(songDuration/1000)}s)`);
                    this.hideNowPlaying();
                    resolve({ duration: songDuration });
                };
                
                this.audioPlayer.src = randomSong;
                this.audioPlayer.play();
                
                const timeout = setTimeout(() => {
                    const songDuration = Date.now() - songStartTime;
                    console.log(`‚è∞ Song timeout reached (${Math.round(songDuration/1000)}s)`);
                    this.audioPlayer.pause();
                    this.hideNowPlaying();
                    resolve({ duration: songDuration, timedOut: true });
                }, 240000);
                
                this.audioPlayer.onended = () => {
                    clearTimeout(timeout);
                    const songDuration = Date.now() - songStartTime;
                    this.hideNowPlaying();
                    resolve({ duration: songDuration });
                };
            });
            
        } catch (error) {
            console.error(`‚ùå Song attempt ${attempt + 1} failed:`, error);
            if (attempt === 2) {
                console.log('üéµ All song attempts failed, continuing without music');
                this.hideNowPlaying();
                await this.delay(30000);
                return { duration: 30000 };
            }
        }
    }
}

        // Sponsor/Advertisement System
        async checkSponsor() {
            if (Math.random() < 0.3) { // 30% chance
                await this.showSponsor();
                return true;
            }
            return false;
        }

        async showSponsor() {
    const videos = [
    'https://res.cloudinary.com/degblqvla/video/upload/v1750983276/ad1_x5dujo.mp4',
    'https://res.cloudinary.com/degblqvla/video/upload/v1750983279/ad2_qghmup.mp4',
    'https://res.cloudinary.com/degblqvla/video/upload/v1750983279/ad3_ziakab.mp4',
    'https://res.cloudinary.com/degblqvla/video/upload/v1750983278/ad4_n3lpfj.mp4',
    'https://res.cloudinary.com/degblqvla/video/upload/v1750983279/ad5_rpxzor.mp4',
    'https://res.cloudinary.com/dwkkbfefj/video/upload/v1751319843/Pumpfun_The_Crypto_Cartoon_zmlgko.mp4',
    'https://res.cloudinary.com/dwkkbfefj/video/upload/v1751319841/SwineU_Meme_Coin_University_Ad_txudlh.mp4',
    'https://res.cloudinary.com/dwkkbfefj/video/upload/v1751319840/OinkCoin_Spa_Crypto_Satire_Video_vimrja.mp4',
    'https://res.cloudinary.com/dwkkbfefj/video/upload/v1751319839/OnlyRugs_A_Crypto_Cartoon_sccqrk.mp4'
];
    
    // Play sponsor intro audio
    this.updateStatus('üì∫ Now a message from our sponsors...');
    this.showPorkyTalking();
    
    try {
        const introAudio = new Audio('https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/audio/sponsor.mp3');
        await new Promise(resolve => {
            introAudio.onended = resolve;
            introAudio.onerror = () => {
                console.error('Sponsor intro audio failed to load');
                resolve();
            };
            introAudio.play().catch(() => {
                console.error('Sponsor intro audio failed to play');
                resolve();
            });
        });
    } catch (error) {
        console.error('Sponsor intro audio error:', error);
    }
    
    this.showStudio();
    
    // Show video ad
    const randomVideo = videos[Math.floor(Math.random() * videos.length)];
    const sponsor = document.getElementById('simpleSponsor');
    const video = document.getElementById('simpleVideo');
    
    video.src = randomVideo;
    video.muted = false;
    sponsor.style.display = 'block';

    // Animate in
    setTimeout(() => {
        sponsor.classList.add('show');
    }, 100);

    video.play();
    
    // Wait for video to finish (8 seconds)
    await new Promise(resolve => setTimeout(resolve, 8000));
    
    // Hide video
    sponsor.classList.remove('show');
    setTimeout(() => {
        sponsor.style.display = 'none';
        video.pause();
    }, 800);
    
    // Play outro audio
    this.showPorkyTalking();
    
    try {
        const outroAudio = new Audio('https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/audio/sponsor1.mp3');
        await new Promise(resolve => {
            outroAudio.onended = resolve;
            outroAudio.onerror = () => {
                console.error('Sponsor outro audio failed to load');
                resolve();
            };
            outroAudio.play().catch(() => {
                console.error('Sponsor outro audio failed to play');
                resolve();
            });
        });
    } catch (error) {
        console.error('Sponsor outro audio error:', error);
    }
    
    this.showStudio();
    this.updateStatus('üìª Back to regular programming!');
}
        // Reporter Functions
        async perkyReport() {
    const content = this.topicInput.value.trim();
    if (!content) {
        this.updateStatus('‚ùå Enter story content for Perky first!');
        return;
    }

    try {
        this.updateStatus('üì∫ Perky is preparing her report...');
        
        const [perkyScript, porkyFollowUp] = await Promise.all([
            this.generatePerkyReport(content),
            this.generatePorkyFollowUp(content, null)
        ]);
        
        this.topicInput.value = '';
        
        this.updateStatus('üì∫ Perky: Live from the newsroom!');
        
        await this.showPerkyReporting();
        
        await this.playTTSAudio(perkyScript, 'perky');
        
        await this.hidePerky();
        
        this.showPorkyTalking();
        this.updateStatus('üéôÔ∏è Porky: Thanks for that update, Perky!');
        
        await this.playTTSAudio(porkyFollowUp, 'porky');
        
        this.showStudio();
        this.updateStatus('üéµ Now spinning tracks after the report...');
        
        await this.playRandomSong();
        
    } catch (error) {
        console.error('Perky report failed:', error);
        this.updateStatus('‚ùå Perky report system malfunction!');
        await this.hidePerky();
    }
}

        async breakingNews() {
    const content = this.topicInput.value.trim();
    if (!content) {
        this.updateStatus('‚ùå Enter breaking news content first!');
        return;
    }

    try {
        this.updateStatus('üö® BREAKING: Porky received urgent intel!');
        
        const radioScript = await this.generateBreakingNewsContent(content);
        
        this.topicInput.value = '';
        
        this.updateStatus('üéôÔ∏è Porky: BREAKING NEWS ALERT!');
        
        // DON'T call showPorkyTalking here - playTTSAudio will handle it
        await this.playTTSAudio(radioScript, 'porky');
        
        this.updateStatus('üìª Breaking news delivered!');
        
    } catch (error) {
        console.error('Breaking news failed:', error);
        this.updateStatus('‚ùå Breaking news system malfunction!');
    }
}
        async showPerkyReporting() {
            return new Promise((resolve) => {
                this.showStudio();
                this.perkyReporter.classList.add('visible');
                console.log('üì∫ Perky sliding into frame... Porky will blink in background');
                setTimeout(resolve, 800);
            });
        }

        async hidePerky() {
            return new Promise((resolve) => {
                this.perkyReporter.classList.remove('visible');
                console.log('üì∫ Perky sliding out of frame...');
                setTimeout(resolve, 800);
            });
        }

        async generateDJDrop() {
    const djDropFiles = [
        'djdrop001.mp3',
        'djdrop002.mp3', 
        'djdrop003.mp3',
        'djdrop004.mp3',
        'djdrop005.mp3',
        'djdrop006.mp3',
        'djdrop007.mp3',
        'djdrop008.mp3',
        'djdrop009.mp3',
        'djdrop010.mp3'
    ];
    
    const randomDrop = djDropFiles[Math.floor(Math.random() * djDropFiles.length)];
    const audioUrl = `https://raw.githubusercontent.com/sovagpt/oiunk/main/assets/audio/djdrops/${randomDrop}`;
    
    try {
        // Test if the file exists
        const response = await fetch(audioUrl, { method: 'HEAD' });
        if (response.ok) {
            return { audioUrl, text: `Playing ${randomDrop}` };
        } else {
            console.log(`DJ drop ${randomDrop} not found`);
            return null;
        }
    } catch (error) {
        console.error('DJ drop file check failed:', error);
        return null;
    }
}

        async scheduleDJDrops() {
    if (!this.isPlaying) return;
    
    // Schedule only 1-2 drops during the song
    const dropCount = Math.floor(Math.random() * 2) + 1; // 1 or 2 drops
    
    for (let i = 0; i < dropCount; i++) {
        const randomTime = Math.random() * 120000 + 60000; // Between 1min and 3min into song
        
        setTimeout(async () => {
            if (this.isPlaying && this.audioPlayer && !this.audioPlayer.paused) {
                console.log('üéôÔ∏è Porky jumping in with a DJ drop...');
                
                const djDrop = await this.generateDJDrop();
                if (djDrop) {
                    this.updateStatus('üéôÔ∏è Porky: DJ Drop!');
                    await this.duckMusicForSpeech(djDrop.audioUrl, djDrop.text, 'porky');
                    this.updateStatus('üéµ Music continuing...');
                } else {
                    console.log('No DJ drop files available - skipping');
                }
            }
        }, randomTime);
    }
}

async duckMusicForSpeech(audioUrl, speechText, voiceType = 'porky') {
    return new Promise((resolve) => {
        // Show Porky talking animation
        this.showPorkyTalking();
        
        // Fade music down to 5%
        this.fadeAudioVolume(1.0, 0.05, 1000);
        
        setTimeout(async () => {
            // Play speech
            const speechAudio = new Audio(audioUrl);
            speechAudio.volume = 1.0;
            
            speechAudio.onended = () => {
                // Go back to studio/blinking when speech ends
                this.showStudio();
                
                // Fade music back up after speech
                setTimeout(() => {
                    this.fadeAudioVolume(0.05, 1.0, 1000);
                    URL.revokeObjectURL(audioUrl);
                    resolve();
                }, 500);
            };
            
            speechAudio.onerror = () => {
                // Go back to studio if audio fails
                this.showStudio();
                this.fadeAudioVolume(0.05, 1.0, 1000);
                URL.revokeObjectURL(audioUrl);
                resolve();
            };
            
            speechAudio.play().catch(() => {
                // Go back to studio if play fails
                this.showStudio();
                this.fadeAudioVolume(0.05, 1.0, 1000);
                resolve();
            });
        }, 1200); // Wait for music to duck down
    });
}

fadeAudioVolume(fromVolume, toVolume, duration) {
    if (!this.audioPlayer) return;
    
    const steps = 20;
    const stepTime = duration / steps;
    const volumeStep = (toVolume - fromVolume) / steps;
    let currentStep = 0;
    
    const fadeInterval = setInterval(() => {
        currentStep++;
        const newVolume = fromVolume + (volumeStep * currentStep);
        this.audioPlayer.volume = Math.max(0, Math.min(1, newVolume));
        
        if (currentStep >= steps) {
            clearInterval(fadeInterval);
            this.audioPlayer.volume = toVolume;
        }
    }, stepTime);
}

        async handlePerkyReport(topic) {
    try {
        this.updateStatus('üì∫ Perky is preparing her report...');
        
        const [perkyScript, porkyFollowUp] = await Promise.all([
            this.generatePerkyReport(topic.content),
            this.generatePorkyFollowUp(topic.content, null)
        ]);
        
        this.updateStatus('üì∫ Perky: Live from the newsroom!');
        await this.showPerkyReporting();
        
        // Perky doesn't need the GIF timing fix since she uses a different animation
        await this.playTTSAudio(perkyScript, 'perky');
        
        await this.hidePerky();
        this.updateStatus('üéôÔ∏è Porky: Thanks for that update, Perky!');
        
        // DON'T call showPorkyTalking here - playTTSAudio will handle it
        await this.playTTSAudio(porkyFollowUp, 'porky');
        
        this.showStudio();
        this.updateStatus('üìª Report complete - back to music...');
        
        this.justCompletedReport = true;
        
    } catch (error) {
        console.error('Perky report handling failed:', error);
        this.updateStatus('‚ùå Perky report system malfunction!');
        await this.hidePerky();
    }
}

        // Main Show Control
        async startShow() {
    if (this.isPlaying) return;
    
    this.isPlaying = true;
    this.justCompletedReport = false;
    this.segmentCount = 0; // Add this new property
    this.maxSegmentsBeforeMusic = 4; // Add this new property
    this.updateStatus("üéôÔ∏è PUMPIE FM is going LIVE!");
    
    // Keep existing social feed and welcome message code...
    
    let queuedTopics = [];
    try {
        const response = await fetch('/api/enhanced-chat?type=queue');
        const data = await response.json();
        queuedTopics = data.queue || [];
    } catch (error) {
        console.error('Failed to fetch queue:', error);
    }
    
    while (this.isPlaying) {
        try {
            // Handle Perky reports immediately
            const urgentPerkyReport = queuedTopics.find(topic => 
                topic.type === 'perky_report' || topic.reporter === 'perky'
            );
            
            if (urgentPerkyReport) {
                await this.handlePerkyReport(urgentPerkyReport);
                await this.removeTopic(urgentPerkyReport.id);
                const refreshResponse = await fetch('/api/enhanced-chat?type=queue');
                const refreshData = await refreshResponse.json();
                queuedTopics = refreshData.queue || [];
                this.segmentCount = 0; // Reset after report
                continue;
            }

            // TALK SEGMENT BLOCK - Multiple segments before music
            if (this.segmentCount < this.maxSegmentsBeforeMusic) {
                const cryptoData = await this.fetchCryptoNews();
                if (cryptoData) {
                    this.updateNewsTicker(cryptoData);
                    this.updateStatus(`ü§ñ Pumpie segment ${this.segmentCount + 1}/${this.maxSegmentsBeforeMusic}...`);
                    
                    const nextTopic = queuedTopics.find(topic => 
                        topic.type !== 'perky_report' && topic.reporter !== 'perky'
                    );
                    
                    const requestType = this.segmentCount === this.maxSegmentsBeforeMusic - 1 ? 'final_segment' : 'segment';
const radioScript = await this.generateRadioContent(cryptoData, nextTopic, requestType);
                    
                    if (nextTopic) {
                        await this.removeTopic(nextTopic.id);
                        const refreshResponse = await fetch('/api/enhanced-chat?type=queue');
                        const refreshData = await refreshResponse.json();
                        queuedTopics = refreshData.queue || [];
                    }
                    
                    this.startSocialFeedForTopic(radioScript, cryptoData);
                    this.updateStatus(`üéôÔ∏è Pumpie dropping knowledge (${this.segmentCount + 1}/${this.maxSegmentsBeforeMusic})...`);
                    
                    await this.playTTSAudio(radioScript, 'pumpie');
                    this.showStudio();
                    this.segmentCount++;
                    
                    // Short pause between segments
                    if (this.segmentCount < this.maxSegmentsBeforeMusic) {
                        this.updateStatus("üìª Brief pause...");
                        await this.delay(2000 + Math.random() * 1000);
                    }
                }
            } else {
                // MUSIC BREAK after talk block
                this.updateStatus("üéµ Time for a music break!");
                
                const transitionMessages = [
                    "PUMP PUMP! That was a lot of alpha, time to vibe with some beats!",
                    "Your brain needs a break from all that pump.fun knowledge - here's some music!",
                    "Time to let those trading insights sink in with some tunes!"
                ];
                
                const randomTransition = transitionMessages[Math.floor(Math.random() * transitionMessages.length)];
                this.updateStatus("üéôÔ∏è Pumpie: Music transition...");
                await this.playTTSAudio(randomTransition, 'pumpie');
                this.showStudio();
                
                this.updateStatus("üéµ Now spinning tracks...");
                await this.playRandomSong();
                
                // Reset for next talk block
                this.segmentCount = 0;
                this.maxSegmentsBeforeMusic = 4 + Math.floor(Math.random() * 3); // 4-6 segments
                
                if (this.isPlaying) {
                    const adPlayed = await this.checkSponsor();
                    if (!adPlayed) {
                        await this.delay(2000);
                    }
                }
            }
            
        } catch (error) {
            console.error('Error in show loop:', error);
            this.updateStatus("‚ö†Ô∏è Something went wrong, retrying...");
            await this.delay(10000);
        }
    }
}

        stop() {
            this.isPlaying = false;
            this.audioPlayer.pause();
            this.stopPorkyBlinking();
            this.hideNowPlaying();
            this.hideSocialFeed();
            this.showStudio();
            this.hidePerky();
            this.updateStatus("üìª OINK FM is off the air");
            speechSynthesis.cancel();
        }

        skipToNext() {
            if (this.isPlaying) {
                this.audioPlayer.pause();
                this.hideNowPlaying();
                speechSynthesis.cancel();
                this.updateStatus("‚è≠Ô∏è Skipping to next segment...");
            }
        }

        showPorkyTalking() {
    this.stopPorkyBlinking();
    if (this.studioImg) {
        this.studioImg.style.display = 'none';
    }
    if (this.porkyGif) {
        this.porkyGif.src = this.porkyGif.src; // Force GIF restart
        this.porkyGif.style.display = 'block';
    }
    if (this.porkyBlink) {
        this.porkyBlink.style.display = 'none';
    }
    if (this.perkyReporter) {
        this.perkyReporter.classList.remove('visible');
    }
    console.log('Porky GIF should be talking now');
}
        showStudio() {
    if (this.porkyGif) {
        this.porkyGif.style.display = 'none';
    }
    if (this.porkyBlink) {
        this.porkyBlink.style.display = 'none';
    }
    if (this.studioImg) {
        this.studioImg.style.display = 'block';
    }
    this.startPorkyBlinking();
    console.log('Showing studio image - Porky will blink randomly');
}

        updateStatus(message) {
            this.statusDisplay.textContent = message;
            console.log(message);
        }

        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    // Initialize the radio
    let radio;

// Wait for DOM to be fully loaded
document.addEventListener('DOMContentLoaded', function() {
    // Initialize radio after DOM is ready
    radio = new OinkFMRadio();
    console.log('üéâ OINK FM Radio initialized successfully!');
});

// Backup initialization in case DOMContentLoaded already fired
if (document.readyState === 'loading') {
    // DOM hasn't finished loading yet
    document.addEventListener('DOMContentLoaded', function() {
        if (!radio) {
            radio = new OinkFMRadio();
            console.log('üéâ OINK FM Radio initialized (backup)!');
        }
    });
} else {
    // DOM has already loaded
    radio = new OinkFMRadio();
    console.log('üéâ OINK FM Radio initialized immediately!');
}
    // Global functions for buttons
    function startShow() {
        radio.startShow();
    }

    function stopShow() {
        radio.stop();
    }

    function skipToNext() {
        radio.skipToNext();
    }

    function addTopic() {
        radio.addTopic();
    }

    function addUrgentTopic() {
        radio.addUrgentTopic();
    }

    function addPerkyReport() {
        radio.addPerkyReport();
    }

    function clearQueue() {
        radio.clearQueue();
    }

    function clearMemory() {
        radio.clearMemory();
    }

    function refreshQueue() {
        radio.refreshQueue();
    }

    function viewMemory() {
        radio.viewMemory();
    }

    function viewKnowledge() {
        radio.viewKnowledge();
    }

    function breakingNews() {
        radio.breakingNews();
    }

    function perkyReport() {
        radio.perkyReport();
    }

    // Load voices when available
    if ('speechSynthesis' in window) {
        speechSynthesis.onvoiceschanged = () => {
            console.log('Available voices:', speechSynthesis.getVoices().map(v => v.name));
        };
    }
</script>
</body>
</html>
